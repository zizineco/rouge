<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <!-- ブラウザウィンドウに合わせたスケーリング -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hengband Web版 - ROT.js サンプル (視界半径5・視界外敵非表示)</title>
  <!-- ROT.js の読み込み（v2） -->
  <script src="https://cdn.jsdelivr.net/npm/rot-js@2/dist/rot.js"></script>
  <style>
    /* html, body をフレックスレイアウトにして、キャンバスをウィンドウ中央に配置 */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #000;
      color: #fff;
      font-family: monospace;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
    }
    /* キャンバスは固定サイズ */
    canvas {
      display: block;
    }
    /* ステータス表示用 overlay（ウィンドウ上部中央） */
    #status {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: calc(1.5em + 1vw);
      pointer-events: none;
    }
    /* 敵セリフ表示用 overlay（ウィンドウ下部中央） */
    #dialogue {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(0,0,0,0.7);
      padding: 10px;
      border: 1px solid #fff;
      font-size: calc(1em + 1vw);
      pointer-events: none;
      color: #ff0;
      display: none;
    }
    /* 拡大縮小ボタン用コンテナ：右下固定 */
    #zoom-controls {
      position: fixed;
      right: 20px;
      bottom: 20px;
    }
    #zoom-controls button {
      font-size: 1.5em;
      padding: 5px 10px;
      margin: 2px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <!-- ステータス表示 -->
  <div id="status"></div>
  <!-- 敵セリフ表示 -->
  <div id="dialogue"></div>
  <!-- 拡大縮小ボタン -->
  <div id="zoom-controls">
    <button id="zoom-in">＋</button>
    <button id="zoom-out">－</button>
  </div>
  <script>
    /* -------------------------------
       定数・グローバル変数
       ------------------------------- */
    const viewWidth = 80;   // 表示するキャンバスのセル数
    const viewHeight = 25;
    const levelWidth = 120; // マップ全体のセル数
    const levelHeight = 40;
    
    // スマホの場合は cellSize = 32、PCは 16（今回はスマホなら32、PCなら16）
    const isMobile = window.innerWidth < 600;
    let cellSize = isMobile ? 32 : 16;
    let displayOptions = {
      width: viewWidth,
      height: viewHeight,
      fontSize: cellSize,
      forceSquareRatio: true,
      bg: "black",
      fg: "white"
    };
    
    let gameOver = false;
    let currentFloor = 1;
    let levels = {};  // 各フロアの状態保存
    
    // レベル生成時に更新される変数
    let map = {};
    let freeCells = [];
    let upStairs = null;
    let downStairs = null;
    let enemies = [];
    
    let player = null;
    
    const attackSound = new Audio('wood.mp3');
    attackSound.volume = 0.5;
    
    const enemyDialogues = [
      "お前の運は尽きた！",
      "これで終わりだ！",
      "死ね！",
      "なめるな！",
      "お前を潰してやる！"
    ];
    
    let display = new ROT.Display(displayOptions);
    display.getContainer().style.width = (viewWidth * cellSize) + "px";
    display.getContainer().style.height = (viewHeight * cellSize) + "px";
    document.body.appendChild(display.getContainer());
    
    /* -------------------------------
       ユーティリティ関数
       ------------------------------- */
    function getRandomFreeCell() {
      return freeCells[Math.floor(ROT.RNG.getUniform() * freeCells.length)];
    }
    function getRandomFreeCellExcluding(exclusions) {
      let candidates = freeCells.filter(cell => {
        for (let ex of exclusions) {
          if (ex && cell.x === ex.x && cell.y === ex.y) return false;
        }
        return true;
      });
      if (candidates.length === 0) return null;
      return candidates[Math.floor(ROT.RNG.getUniform() * candidates.length)];
    }
    function getNearestFreeCell(target) {
      let minDist = Infinity;
      let nearest = null;
      freeCells.forEach(cell => {
        let dx = cell.x - target.x, dy = cell.y - target.y;
        let dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < minDist) {
          minDist = dist;
          nearest = cell;
        }
      });
      return nearest;
    }
    
    /* -------------------------------
       タッチイベント設定
       ------------------------------- */
    let touchStartX = null, touchStartY = null;
    const swipeThreshold = 30;
    function onTouchStart(e) {
      const touch = e.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
      e.preventDefault();
    }
    function onTouchEnd(e) {
      if (touchStartX === null || touchStartY === null) return;
      const touch = e.changedTouches[0];
      let deltaX = touch.clientX - touchStartX;
      let deltaY = touch.clientY - touchStartY;
      if (Math.abs(deltaX) < swipeThreshold && Math.abs(deltaY) < swipeThreshold) {
        touchStartX = null;
        touchStartY = null;
        return;
      }
      let angle = Math.atan2(deltaY, deltaX);
      let step = Math.PI / 4;
      let normalized = (angle + 2 * Math.PI) % (2 * Math.PI);
      let offsetAngle = 3 * Math.PI / 2;
      let adjustedAngle = (normalized - offsetAngle + 2 * Math.PI) % (2 * Math.PI);
      let index = Math.floor((adjustedAngle + step / 2) / step) % 8;
      let dir = ROT.DIRS[8][index];
      autoRun(dir);
      touchStartX = null;
      touchStartY = null;
      e.preventDefault();
    }
    display.getContainer().addEventListener('touchstart', onTouchStart, false);
    display.getContainer().addEventListener('touchend', onTouchEnd, false);
    
    /* -------------------------------
       視界計算（FOV, 半径5セル）
       ------------------------------- */
    function computeFov() {
      let visibleCells = {};
      let fov = new ROT.FOV.PreciseShadowcasting((x, y) => {
        return map[x + "," + y] !== "#";
      });
      fov.compute(player.x, player.y, 5, (x, y, r, vis) => {
        visibleCells[x + "," + y] = true;
      });
      return visibleCells;
    }
    
    /* -------------------------------
       自動ラン機能（スワイプ入力時のみ）
       ------------------------------- */
    // 自動ラン中は、敵が視界内に入ったら中断する
    function autoRun(dir) {
      if (gameOver) return;
      let newX = player.x + dir[0];
      let newY = player.y + dir[1];
      let newKey = newX + "," + newY;
      if ((downStairs && newX === downStairs.x && newY === downStairs.y) ||
          (upStairs && newX === upStairs.x && newY === upStairs.y)) {
        changeFloor(downStairs && newX === downStairs.x ? 'down' : 'up');
        return;
      }
      let enemy = enemies.find(e => e.x === newX && e.y === newY);
      if (enemy) {
        playerAttack(enemy);
        render();
        return;
      }
      if (map[newKey] !== ".") return;
      
      player.x = newX;
      player.y = newY;
      moveEnemies();
      render();
      
      // もし視界内（半径5セル）のFOV計算で敵が見えたら中断
      let fovCells = computeFov();
      let enemyVisible = enemies.some(e => fovCells[e.x + "," + e.y]);
      if (enemyVisible) return;
      
      // もし新たな位置の周囲の自由セル数が3以上（＝分岐）なら中断
      let freeCount = 0;
      ROT.DIRS[8].forEach(d => {
        let nx = newX + d[0];
        let ny = newY + d[1];
        if (map[nx + "," + ny] === ".") freeCount++;
      });
      if (freeCount > 2) return;
      
      setTimeout(() => { autoRun(dir); }, 150);
    }
    
    /* -------------------------------
       レベル生成・再生成
       forcedUpStairs: 下るとき、前階の下り階段位置を上り階段として固定
       forcedDownStairs: 上るとき、前階の上り階段位置を下り階段として固定
       ------------------------------- */
    function generateLevel(forcedUpStairs = null, forcedDownStairs = null) {
      if (levels[currentFloor]) {
        let levelData = levels[currentFloor];
        map = levelData.map;
        freeCells = levelData.freeCells;
        upStairs = levelData.upStairs;
        downStairs = levelData.downStairs;
        enemies = levelData.enemies;
        if (levelData.playerPos) {
          player.x = levelData.playerPos.x;
          player.y = levelData.playerPos.y;
        }
        render();
        return;
      }
      map = {};
      freeCells = [];
      let digger = new ROT.Map.Digger(levelWidth, levelHeight);
      digger.create((x, y, value) => {
        const key = x + "," + y;
        if (value) {
          map[key] = "#";
        } else {
          map[key] = ".";
          freeCells.push({ x: x, y: y });
        }
      });
      if (currentFloor === 1) {
        downStairs = getRandomFreeCell();
        upStairs = null;
      } else {
        if (forcedUpStairs) {
          let found = freeCells.find(cell => cell.x === forcedUpStairs.x && cell.y === forcedUpStairs.y);
          upStairs = found ? forcedUpStairs : getNearestFreeCell(forcedUpStairs);
        } else {
          upStairs = getRandomFreeCell();
        }
        if (forcedDownStairs) {
          let found = freeCells.find(cell => cell.x === forcedDownStairs.x && cell.y === forcedDownStairs.y);
          downStairs = found ? forcedDownStairs : getNearestFreeCell(forcedDownStairs);
        } else {
          do {
            downStairs = getRandomFreeCell();
          } while (downStairs.x === upStairs.x && downStairs.y === upStairs.y);
        }
      }
      if (!player) {
        let start = getRandomFreeCellExcluding([upStairs, downStairs]);
        player = { x: start.x, y: start.y, hp: 20 };
      }
      enemies = [];
      const enemyCount = 3;
      while (enemies.length < enemyCount) {
        let cell = getRandomFreeCellExcluding([upStairs, downStairs, player]);
        if (!cell) break;
        cell.hp = 10;
        cell.alerted = false;
        enemies.push(cell);
      }
      levels[currentFloor] = {
        map: map,
        freeCells: freeCells,
        upStairs: upStairs,
        downStairs: downStairs,
        enemies: enemies,
        playerPos: { x: player.x, y: player.y }
      };
      render();
    }
    
    /* -------------------------------
       描画関数（カメラ機能付き）
       ------------------------------- */
    // カメラオフセット = (viewWidth/2, viewHeight/2) - player座標
    function render() {
      display.clear();
      let centerX = Math.floor(viewWidth / 2);
      let centerY = Math.floor(viewHeight / 2);
      let offsetX = centerX - player.x;
      let offsetY = centerY - player.y;
      
      // FOV計算（半径5セル）
      let visibleCells = {};
      let fov = new ROT.FOV.PreciseShadowcasting((x, y) => {
        return map[x + "," + y] !== "#";
      });
      fov.compute(player.x, player.y, 5, (x, y, r, vis) => {
        visibleCells[x + "," + y] = true;
      });
      
      drawMap(offsetX, offsetY, visibleCells);
      drawStairs(offsetX, offsetY);
      drawEnemies(offsetX, offsetY, visibleCells);
      drawPlayer(offsetX, offsetY);
      updateStatus();
    }
    function drawMap(offsetX, offsetY, visibleCells) {
      for (let key in map) {
        const parts = key.split(",");
        const x = parseInt(parts[0]) + offsetX;
        const y = parseInt(parts[1]) + offsetY;
        let color;
        if (visibleCells[key]) {
          color = (map[key] === "#") ? "grey" : "lightgrey";
        } else {
          color = (map[key] === "#") ? "darkslategray" : "dimgray";
        }
        display.draw(x, y, map[key], color);
      }
    }
    function drawStairs(offsetX, offsetY) {
      if (upStairs) display.draw(upStairs.x + offsetX, upStairs.y + offsetY, "<", "lightblue");
      if (downStairs) display.draw(downStairs.x + offsetX, downStairs.y + offsetY, ">", "lightblue");
    }
    function drawPlayer(offsetX, offsetY) {
      display.draw(player.x + offsetX, player.y + offsetY, "@", "yellow");
    }
    function drawEnemies(offsetX, offsetY, visibleCells) {
      enemies.forEach(e => {
        if (visibleCells[e.x + "," + e.y]) {
          display.draw(e.x + offsetX, e.y + offsetY, "E", "red");
        }
      });
    }
    function updateStatus() {
      document.getElementById("status").innerText = "HP: " + player.hp + "   Floor: " + currentFloor;
    }
    
    /* -------------------------------
       攻撃エフェクト・攻撃処理
       ------------------------------- */
    function showAttackEffect(x, y) {
      const frames = [
        { symbol: "!", color: "orange" },
        { symbol: "*", color: "red" },
        { symbol: "!", color: "yellow" }
      ];
      let frame = 0;
      const interval = setInterval(() => {
        if (frame < frames.length) {
          let centerX = Math.floor(viewWidth / 2);
          let centerY = Math.floor(viewHeight / 2);
          let offsetX = centerX - player.x;
          let offsetY = centerY - player.y;
          display.draw(x + offsetX, y + offsetY, frames[frame].symbol, frames[frame].color);
          frame++;
        } else {
          clearInterval(interval);
          render();
        }
      }, 100);
    }
    function playerAttack(enemy) {
      attackSound.currentTime = 0;
      attackSound.play().catch(e => console.error("Sound playback error:", e));
      showAttackEffect(enemy.x, enemy.y);
      const damage = 5;
      enemy.hp -= damage;
      console.log("Player attacks enemy! Damage:", damage, "Enemy HP:", enemy.hp);
      if (enemy.hp <= 0) {
        console.log("Enemy defeated!");
        const idx = enemies.indexOf(enemy);
        if (idx > -1) enemies.splice(idx, 1);
      }
    }
    function enemyAttack(enemy) {
      attackSound.currentTime = 0;
      attackSound.play().catch(e => console.error("Sound playback error:", e));
      let msg = enemyDialogues[Math.floor(Math.random() * enemyDialogues.length)];
      enemySpeak(msg);
      showAttackEffect(player.x, player.y);
      const damage = 3;
      player.hp -= damage;
      console.log("Enemy attacks player! Damage:", damage, "Player HP:", player.hp);
      if (player.hp <= 0) {
        console.log("Player is defeated! Game Over!");
        gameOver = true;
      }
    }
    function enemySpeak(message) {
      let dialogue = document.getElementById("dialogue");
      dialogue.innerText = message;
      dialogue.style.display = "block";
      setTimeout(() => { dialogue.style.display = "none"; }, 3000);
    }
    function moveEnemies() {
      enemies.forEach(enemy => {
        let dx = enemy.x - player.x;
        let dy = enemy.y - player.y;
        let dist = Math.sqrt(dx * dx + dy * dy);
        if (!enemy.alerted) {
          if (dist <= 10) enemy.alerted = true;
          else return;
        }
        if (Math.abs(enemy.x - player.x) <= 1 && Math.abs(enemy.y - player.y) <= 1) {
          enemyAttack(enemy);
          return;
        }
        let astar = new ROT.Path.AStar(player.x, player.y, (x, y) => {
          return map[x + "," + y] === ".";
        }, { topology: 8 });
        let path = [];
        astar.compute(enemy.x, enemy.y, (x, y) => { path.push({ x, y }); });
        if (path.length > 1) {
          enemy.x = path[1].x;
          enemy.y = path[1].y;
        }
      });
    }
    
    /* -------------------------------
       フロア変更処理
       ------------------------------- */
    function changeFloor(direction) {
      if (!levels[currentFloor]) levels[currentFloor] = {};
      levels[currentFloor].playerPos = { x: player.x, y: player.y };
      if (direction === 'down') {
        let forced = levels[currentFloor].downStairs;
        currentFloor++;
        generateLevel(forced, null);
        player.x = upStairs.x;
        player.y = upStairs.y;
        levels[currentFloor].playerPos = { x: player.x, y: player.y };
      } else if (direction === 'up') {
        if (currentFloor === 1) return;
        let forced = levels[currentFloor].upStairs;
        currentFloor--;
        generateLevel(null, forced);
        player.x = downStairs.x;
        player.y = downStairs.y;
        levels[currentFloor].playerPos = { x: player.x, y: player.y };
      }
      render();
    }
    
    /* -------------------------------
       キーボード入力処理
       ------------------------------- */
    window.addEventListener("keydown", function(e) {
      if (gameOver) return;
      const keyMap = {38:0, 33:1, 39:2, 34:3, 40:4, 35:5, 37:6, 36:7};
      if (!(e.keyCode in keyMap)) return;
      const dir = ROT.DIRS[8][keyMap[e.keyCode]];
      const newX = player.x + dir[0];
      const newY = player.y + dir[1];
      const newKey = newX + "," + newY;
      if (downStairs && newX === downStairs.x && newY === downStairs.y) {
        changeFloor('down');
        return;
      }
      if (upStairs && newX === upStairs.x && newY === upStairs.y) {
        changeFloor('up');
        return;
      }
      const enemy = enemies.find(e => e.x === newX && e.y === newY);
      if (enemy) {
        playerAttack(enemy);
        render();
        return;
      }
      if (map[newKey] === ".") {
        player.x = newX;
        player.y = newY;
        moveEnemies();
        render();
      }
    });
    
    /* -------------------------------
       拡大縮小機能
       ------------------------------- */
    function updateDisplay() {
      let container = display.getContainer();
      if (container.parentNode) {
        container.parentNode.removeChild(container);
      }
      displayOptions.fontSize = cellSize;
      display = new ROT.Display(displayOptions);
      display.getContainer().style.width = (viewWidth * cellSize) + "px";
      display.getContainer().style.height = (viewHeight * cellSize) + "px";
      document.body.appendChild(display.getContainer());
      display.getContainer().addEventListener('touchstart', onTouchStart, false);
      display.getContainer().addEventListener('touchend', onTouchEnd, false);
      render();
    }
    function zoomIn() {
      cellSize += 4;
      updateDisplay();
    }
    function zoomOut() {
      if (cellSize > 8) {
        cellSize -= 4;
        updateDisplay();
      }
    }
    document.getElementById("zoom-in").addEventListener("click", zoomIn);
    document.getElementById("zoom-out").addEventListener("click", zoomOut);
    
    /* -------------------------------
       初期レベル生成
       ------------------------------- */
    generateLevel();
  </script>
</body>
</html>
