[
  {
    "filename": "index.html",
    "content": "<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"UTF-8\">\n  <!-- ブラウザウィンドウに合わせたスケーリング -->\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Hengband Web版 - ROT.js サンプル (視界半径5・経験値・レベル・回復アイテム＆武器機能実装・複数敵タイプ対応)</title>\n  <!-- ROT.js の読み込み（v2） -->\n  <script src=\"https://cdn.jsdelivr.net/npm/rot-js@2/dist/rot.js\"></script>\n  <!-- 外部CSS読み込み -->\n  <link rel=\"stylesheet\" href=\"style.css\">\n</head>\n<body>\n  <!-- ステータス表示 -->\n  <div id=\"status\"></div>\n  <!-- 敵セリフ表示 -->\n  <div id=\"dialogue\"></div>\n  <!-- 敵ステータス表示 -->\n  <div id=\"enemy-status\"></div>\n  <!-- ヘルプ画面用オーバーレイ -->\n  <div id=\"help\">\n    <h2>ヘルプ</h2>\n    <ul>\n      <li><strong>矢印キー（またはテンキー）</strong>：移動</li>\n      <li><strong>U</strong>：回復ポーション使用</li>\n      <li><strong>E</strong>：武器装備</li>\n      <li><strong>M</strong>：全体マップ表示/非表示</li>\n      <li><strong>H</strong>：ヘルプ画面表示/非表示</li>\n      <li><strong>クリック／タップ</strong>：敵のステータス表示および選択</li>\n      <li><strong>スワイプ</strong>：自動ラン移動</li>\n      <li><strong>Zoom In/Out</strong>：画面右下のボタン</li>\n      <li><strong>履歴</strong>：画面左下の「履歴」ボタンでメッセージ履歴の表示</li>\n    </ul>\n    <p>ヘルプ画面を閉じるには、H キーを押すか、ヘルプ画面上をクリックしてください。</p>\n  </div>\n  <!-- メッセージ履歴用オーバーレイ -->\n  <div id=\"message-history-overlay\">\n    <h2>メッセージ履歴</h2>\n    <div id=\"message-history-content\"></div>\n    <p>閉じるには、左下の「履歴」ボタンを再度クリックしてください。</p>\n  </div>\n  <!-- 拡大縮小ボタン -->\n  <div id=\"zoom-controls\">\n    <button id=\"zoom-in\">＋</button>\n    <button id=\"zoom-out\">－</button>\n  </div>\n  <!-- メッセージ履歴ボタン -->\n  <div id=\"history-controls\">\n    <button id=\"history-toggle\">履歴</button>\n  </div>\n  <!-- 全体マップ表示用コンテナ -->\n  <div id=\"fullmap\"></div>\n\n  <!-- メインスクリプト（モジュールとして読み込む） -->\n  <script type=\"module\" src=\"main.mjs\"></script>\n</body>\n</html>\n\n"
  },
  {
    "filename": "config.mjs",
    "content": "export const viewWidth = 80;       // 表示キャンバスのセル数（横）\nexport const viewHeight = 25;      // 表示キャンバスのセル数（縦）\nexport const levelWidth = 120;     // マップ全体のセル数（横）\nexport const levelHeight = 40;     // マップ全体のセル数（縦）\n\nexport const isMobile = window.innerWidth < 600;\nexport let cellSize = isMobile ? 32 : 16;\n\nexport const displayOptions = {\n  width: viewWidth,\n  height: viewHeight,\n  fontSize: cellSize,\n  forceSquareRatio: true,\n  bg: \"black\",\n  fg: \"white\"\n};\n\n"
  },
  {
    "filename": "game.mjs",
    "content": "import { viewWidth, viewHeight, levelWidth, levelHeight, displayOptions, isMobile, cellSize } from './config.mjs';\n\nexport class Game {\n  constructor() {\n    // ゲーム状態の初期化\n    this.gameOver = false;\n    this.currentFloor = 1;\n    this.levels = {};         // 各フロアの状態保存\n    this.messageHistory = []; // メッセージ履歴を保存する配列\n\n    // レベル生成時の状態変数\n    this.map = {};\n    this.freeCells = [];\n    this.upStairs = null;\n    this.downStairs = null;\n    this.enemies = [];\n    this.healingItems = [];  // 回復アイテム（ポーション）\n    this.weaponItems = [];   // 床に落ちた武器\n    this.player = null;\n\n    // サウンドとセリフ\n    this.attackSound = new Audio('wood.mp3');\n    this.attackSound.volume = 0.5;\n    this.enemyDialogues = [\n      'お前の運は尽きた！',\n      'これで終わりだ！',\n      '死ね！',\n      'なめるな！',\n      'お前を潰してやる！'\n    ];\n\n    // ROT.js の display 初期化\n    this.display = new ROT.Display(displayOptions);\n    this.updateDisplaySize();\n    document.body.appendChild(this.display.getContainer());\n\n    // タッチイベント関連の初期化\n    this.touchStartX = null;\n    this.touchStartY = null;\n    this.swipeThreshold = 30;\n    this.registerTouchEvents();\n\n    // キーボードイベント登録\n    window.addEventListener('keydown', this.handleKeyDown.bind(this));\n\n    // マウスクリックイベント登録（敵クリック用）\n    const container = this.display.getContainer();\n    if (container) {\n      container.addEventListener('click', this.onClick.bind(this));\n    }\n\n    // 各ボタンのイベント登録\n    const zoomInEl = document.getElementById('zoom-in');\n    if (zoomInEl) {\n      zoomInEl.addEventListener('click', this.zoomIn.bind(this));\n    }\n    const zoomOutEl = document.getElementById('zoom-out');\n    if (zoomOutEl) {\n      zoomOutEl.addEventListener('click', this.zoomOut.bind(this));\n    }\n    const helpEl = document.getElementById('help');\n    if (helpEl) {\n      helpEl.addEventListener('click', this.toggleHelp.bind(this));\n    }\n    const historyToggleEl = document.getElementById('history-toggle');\n    if (historyToggleEl) {\n      historyToggleEl.addEventListener('click', this.toggleHistory.bind(this));\n    }\n\n    // 全体マップ表示用のプロパティ\n    this.overviewMode = false;\n    this.fullMapDisplay = null;\n\n    // 初期レベル生成\n    this.generateLevel();\n  }\n\n  /* キーボード入力処理 */\n  handleKeyDown(e) {\n    if (this.gameOver) return;\n    let dx = 0, dy = 0;\n    switch(e.key) {\n      case 'ArrowUp':\n      case 'w':\n      case 'W':\n        dy = -1;\n        break;\n      case 'ArrowDown':\n      case 's':\n      case 'S':\n        dy = 1;\n        break;\n      case 'ArrowLeft':\n      case 'a':\n      case 'A':\n        dx = -1;\n        break;\n      case 'ArrowRight':\n      case 'd':\n      case 'D':\n        dx = 1;\n        break;\n      case 'u':\n      case 'U':\n        this.useHealingItem();\n        return;\n      case 'e':\n      case 'E':\n        this.equipWeapon();\n        return;\n      case 'h':\n      case 'H':\n        this.toggleHelp();\n        return;\n      case 'm':\n      case 'M':\n        this.toggleOverview();\n        return;\n      default:\n        return;\n    }\n    if (dx !== 0 || dy !== 0) {\n      this.movePlayer(dx, dy);\n      e.preventDefault();\n    }\n  }\n\n  /* プレイヤーの移動処理 */\n  movePlayer(dx, dy) {\n    if (this.gameOver) return;\n    const newX = this.player.x + dx;\n    const newY = this.player.y + dy;\n    const newKey = newX + ',' + newY;\n\n    // 階段の判定\n    if ((this.downStairs && newX === this.downStairs.x && newY === this.downStairs.y) ||\n        (this.upStairs   && newX === this.upStairs.x   && newY === this.upStairs.y)) {\n      this.changeFloor((this.downStairs && newX === this.downStairs.x) ? 'down' : 'up');\n      return;\n    }\n\n    // 敵の判定\n    const enemy = this.enemies.find(e => e.x === newX && e.y === newY);\n    if (enemy) {\n      this.playerAttack(enemy);\n      this.render();\n      return;\n    }\n\n    // 通路・部屋判定\n    if (this.map[newKey] !== '.') return;\n\n    // 移動してエネミー移動\n    this.player.x = newX;\n    this.player.y = newY;\n    this.checkPickup();\n    this.moveEnemies();\n    this.render();\n  }\n\n  /* Display サイズ更新 */\n  updateDisplaySize() {\n    const container = this.display.getContainer();\n    container.style.width  = (viewWidth * cellSize) + 'px';\n    container.style.height = (viewHeight * cellSize) + 'px';\n  }\n\n  /* タッチイベント登録 */\n  registerTouchEvents() {\n    const container = this.display.getContainer();\n    if (container) {\n      container.addEventListener('touchstart', this.onTouchStart.bind(this), false);\n      container.addEventListener('touchend',   this.onTouchEnd.bind(this), false);\n    }\n  }\n\n  onTouchStart(e) {\n    const touch = e.touches[0];\n    this.touchStartX = touch.clientX;\n    this.touchStartY = touch.clientY;\n    e.preventDefault();\n  }\n\n  onTouchEnd(e) {\n    if (this.touchStartX === null || this.touchStartY === null) return;\n    const touch = e.changedTouches[0];\n    const deltaX = touch.clientX - this.touchStartX;\n    const deltaY = touch.clientY - this.touchStartY;\n\n    // スワイプ距離が短い → タップ扱い\n    if (Math.abs(deltaX) < this.swipeThreshold && Math.abs(deltaY) < this.swipeThreshold) {\n      this.handleInteraction(touch.clientX, touch.clientY);\n      this.touchStartX = null;\n      this.touchStartY = null;\n      return;\n    }\n\n    // スワイプ → 自動ラン\n    let angle = Math.atan2(deltaY, deltaX);\n    const step = Math.PI / 4;\n    let normalized = (angle + 2 * Math.PI) % (2 * Math.PI);\n    const offsetAngle = 3 * Math.PI / 2;\n    let adjustedAngle = (normalized - offsetAngle + 2 * Math.PI) % (2 * Math.PI);\n    let index = Math.floor((adjustedAngle + step / 2) / step) % 8;\n    const dir = ROT.DIRS[8][index];\n    this.autoRun(dir);\n    this.touchStartX = null;\n    this.touchStartY = null;\n    e.preventDefault();\n  }\n\n  /* クリック処理（敵選択など） */\n  onClick(e) {\n    this.handleInteraction(e.clientX, e.clientY);\n  }\n\n  handleInteraction(clientX, clientY) {\n    const container = this.display.getContainer();\n    const rect = container.getBoundingClientRect();\n    const xPixel = clientX - rect.left;\n    const yPixel = clientY - rect.top;\n    const cellX = Math.floor(xPixel / cellSize);\n    const cellY = Math.floor(yPixel / cellSize);\n    const centerX = Math.floor(viewWidth / 2);\n    const centerY = Math.floor(viewHeight / 2);\n    const offsetX = centerX - this.player.x;\n    const offsetY = centerY - this.player.y;\n    const mapX = cellX - offsetX;\n    const mapY = cellY - offsetY;\n\n    // 敵をクリックしたか判定\n    const enemy = this.enemies.find(e => e.x === mapX && e.y === mapY);\n    if (enemy) {\n      this.enemies.forEach(e => e.selected = false);\n      enemy.selected = true;\n      this.showEnemyStatus(enemy);\n      this.render();\n    } else {\n      this.enemies.forEach(e => e.selected = false);\n      this.clearEnemyStatus();\n      this.render();\n    }\n  }\n\n  /* 敵ステータス表示 */\n  showEnemyStatus(enemy) {\n    const enemyStatusEl = document.getElementById('enemy-status');\n    enemyStatusEl.innerText = `Enemy: ${enemy.name}   HP: ${enemy.hp}`;\n    enemyStatusEl.style.display = 'block';\n  }\n\n  clearEnemyStatus() {\n    const enemyStatusEl = document.getElementById('enemy-status');\n    enemyStatusEl.style.display = 'none';\n  }\n\n  /* メッセージ表示＆履歴 */\n  showDialogue(message) {\n    this.messageHistory.push(message);\n    const dialogue = document.getElementById('dialogue');\n    dialogue.innerText = message;\n    dialogue.style.display = 'block';\n    setTimeout(() => { dialogue.style.display = 'none'; }, 2000);\n  }\n\n  updateMessageHistoryOverlay() {\n    const contentEl = document.getElementById('message-history-content');\n    let html = '<ul>';\n    this.messageHistory.forEach(msg => {\n      html += `<li>${msg}</li>`;\n    });\n    html += '</ul>';\n    contentEl.innerHTML = html;\n  }\n\n  toggleHelp() {\n    const helpEl = document.getElementById('help');\n    helpEl.style.display = (helpEl.style.display === 'block') ? 'none' : 'block';\n  }\n\n  toggleHistory() {\n    const overlay = document.getElementById('message-history-overlay');\n    if (overlay.style.display === 'block') {\n      overlay.style.display = 'none';\n    } else {\n      this.updateMessageHistoryOverlay();\n      overlay.style.display = 'block';\n    }\n  }\n\n  /* ユーティリティ関数 */\n  getRandomFreeCell() {\n    return this.freeCells[Math.floor(ROT.RNG.getUniform() * this.freeCells.length)];\n  }\n\n  getRandomFreeCellExcluding(exclusions = []) {\n    const candidates = this.freeCells.filter(cell => {\n      return !exclusions.some(ex => ex && cell.x === ex.x && cell.y === ex.y);\n    });\n    return candidates.length\n      ? candidates[Math.floor(ROT.RNG.getUniform() * candidates.length)]\n      : null;\n  }\n\n  getNearestFreeCell(target) {\n    let minDist = Infinity;\n    let nearest = null;\n    this.freeCells.forEach(cell => {\n      const dx = cell.x - target.x;\n      const dy = cell.y - target.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n      if (dist < minDist) {\n        minDist = dist;\n        nearest = cell;\n      }\n    });\n    return nearest;\n  }\n\n  /* 視界計算（FOV 半径5） */\n  computeFov() {\n    const visibleCells = {};\n    const fov = new ROT.FOV.PreciseShadowcasting((x, y) => {\n      return this.map[`${x},${y}`] !== '#';\n    });\n    fov.compute(this.player.x, this.player.y, 5, (x, y) => {\n      visibleCells[`${x},${y}`] = true;\n    });\n    return visibleCells;\n  }\n\n  /* 自動ラン（スワイプ時） */\n  autoRun(dir) {\n    if (this.gameOver) return;\n    this.movePlayer(dir[0], dir[1]);\n    const fovCells = this.computeFov();\n    const enemyVisible = this.enemies.some(e => fovCells[`${e.x},${e.y}`]);\n    if (enemyVisible) return;\n\n    // 回り道が多い場所では止まる\n    let freeCount = 0;\n    const newX = this.player.x;\n    const newY = this.player.y;\n    ROT.DIRS[8].forEach(d => {\n      const nx = newX + d[0];\n      const ny = newY + d[1];\n      if (this.map[`${nx},${ny}`] === '.') freeCount++;\n    });\n    if (freeCount > 2) return;\n\n    // 次のステップ\n    setTimeout(() => { this.autoRun(dir); }, 150);\n  }\n\n  /* レベル生成・再生成 */\n  generateLevel(forcedUpStairs = null, forcedDownStairs = null) {\n    if (this.levels[this.currentFloor]) {\n      // 既存データをロード\n      const levelData = this.levels[this.currentFloor];\n      this.map          = levelData.map;\n      this.freeCells    = levelData.freeCells;\n      this.upStairs     = levelData.upStairs;\n      this.downStairs   = levelData.downStairs;\n      this.enemies      = levelData.enemies;\n      this.healingItems = levelData.healingItems || [];\n      this.weaponItems  = levelData.weaponItems  || [];\n      if (levelData.playerPos) {\n        this.player.x = levelData.playerPos.x;\n        this.player.y = levelData.playerPos.y;\n      }\n      this.render();\n      return;\n    }\n\n    // 新規レベル生成\n    this.map = {};\n    this.freeCells = [];\n    const digger = new ROT.Map.Digger(levelWidth, levelHeight);\n    digger.create((x, y, value) => {\n      const key = `${x},${y}`;\n      if (value) {\n        this.map[key] = '#';\n      } else {\n        this.map[key] = '.';\n        this.freeCells.push({ x, y });\n      }\n    });\n\n    if (this.currentFloor === 1) {\n      this.downStairs = this.getRandomFreeCell();\n      this.upStairs = null;\n    } else {\n      // 上り階段\n      this.upStairs = (\n        forcedUpStairs &&\n        this.freeCells.find(cell => cell.x === forcedUpStairs.x && cell.y === forcedUpStairs.y)\n      )\n        ? forcedUpStairs\n        : (forcedUpStairs ? this.getNearestFreeCell(forcedUpStairs) : this.getRandomFreeCell());\n\n      // 下り階段\n      if (forcedDownStairs) {\n        this.downStairs = (\n          this.freeCells.find(cell => cell.x === forcedDownStairs.x && cell.y === forcedDownStairs.y)\n        )\n          ? forcedDownStairs\n          : this.getNearestFreeCell(forcedDownStairs);\n      } else {\n        do {\n          this.downStairs = this.getRandomFreeCell();\n        } while (\n          this.downStairs.x === this.upStairs.x &&\n          this.downStairs.y === this.upStairs.y\n        );\n      }\n    }\n\n    if (!this.player) {\n      const start = this.getRandomFreeCellExcluding([this.upStairs, this.downStairs]);\n      this.player = {\n        x: start.x,\n        y: start.y,\n        hp: 20,\n        maxHp: 20,\n        level: 1,\n        exp: 0,\n        nextExp: 20,\n        inventory: [],\n        weapons: [],\n        equippedWeapon: null\n      };\n    }\n\n    // 敵配置\n    this.enemies = [];\n    const enemyCount = 3;\n    const enemyTypes = [\n      {\n        type: 'Goblin',\n        symbol: 'g',\n        color: 'green',\n        baseHp: 8,\n        senseRadius: 6,\n        drop: { name: 'Rusty Dagger', bonus: 1, symbol: 'd', color: 'white' }\n      },\n      {\n        type: 'Orc',\n        symbol: 'o',\n        color: 'orange',\n        baseHp: 12,\n        senseRadius: 8,\n        drop: { name: 'Orcish Axe', bonus: 2, symbol: 'A', color: 'brown' }\n      },\n      {\n        type: 'Troll',\n        symbol: 'T',\n        color: 'darkgreen',\n        baseHp: 20,\n        senseRadius: 10,\n        drop: { name: 'Heavy Club', bonus: 3, symbol: 'C', color: 'gray' }\n      }\n    ];\n\n    while (this.enemies.length < enemyCount) {\n      const cell = this.getRandomFreeCellExcluding([\n        this.upStairs, this.downStairs, this.player\n      ]);\n      if (!cell) break;\n      const enemyType = enemyTypes[Math.floor(ROT.RNG.getUniform() * enemyTypes.length)];\n      cell.hp = enemyType.baseHp + (this.currentFloor - 1) * 2;\n      cell.level = this.currentFloor;\n      cell.symbol = enemyType.symbol;\n      cell.color = enemyType.color;\n      cell.senseRadius = enemyType.senseRadius;\n      cell.drop = enemyType.drop;\n      cell.name = enemyType.type;\n      cell.alerted = false;\n      cell.selected = false;\n      this.enemies.push(cell);\n    }\n\n    // 回復アイテム配置\n    const healingItemCount = 3;\n    this.healingItems = [];\n    while (this.healingItems.length < healingItemCount) {\n      const cell = this.getRandomFreeCellExcluding([\n        this.upStairs, this.downStairs, this.player,\n        ...this.enemies, ...this.healingItems\n      ]);\n      if (!cell) break;\n      cell.amount = 10;\n      this.healingItems.push(cell);\n    }\n\n    // 武器アイテム配置（初期は空）\n    this.weaponItems = [];\n\n    // レベル情報を保存\n    this.levels[this.currentFloor] = {\n      map: this.map,\n      freeCells: this.freeCells,\n      upStairs: this.upStairs,\n      downStairs: this.downStairs,\n      enemies: this.enemies,\n      healingItems: this.healingItems,\n      weaponItems: this.weaponItems,\n      playerPos: { x: this.player.x, y: this.player.y }\n    };\n\n    this.render();\n  }\n\n  /* 描画 */\n  render() {\n    this.display.clear();\n    const centerX = Math.floor(viewWidth / 2);\n    const centerY = Math.floor(viewHeight / 2);\n    const offsetX = centerX - this.player.x;\n    const offsetY = centerY - this.player.y;\n    const visibleCells = this.computeFov();\n\n    this.drawMap(offsetX, offsetY, visibleCells);\n    this.drawStairs(offsetX, offsetY);\n    this.drawHealingItems(offsetX, offsetY, visibleCells);\n    this.drawWeaponItems(offsetX, offsetY, visibleCells);\n    this.drawEnemies(offsetX, offsetY, visibleCells);\n    this.drawPlayer(offsetX, offsetY);\n    this.updateStatus();\n\n    // 全体マップモード\n    if (this.overviewMode && this.fullMapDisplay) {\n      this.renderFullMap();\n      const fullMapContainer = document.getElementById('fullmap');\n      fullMapContainer.innerHTML = '';\n      fullMapContainer.appendChild(this.fullMapDisplay.getContainer());\n    }\n  }\n\n  drawMap(offsetX, offsetY, visibleCells) {\n    for (let key in this.map) {\n      const [xStr, yStr] = key.split(',');\n      const x = parseInt(xStr) + offsetX;\n      const y = parseInt(yStr) + offsetY;\n      let color;\n      if (visibleCells[key]) {\n        color = (this.map[key] === '#') ? 'grey' : 'lightgrey';\n      } else {\n        color = (this.map[key] === '#') ? 'darkslategray' : 'dimgray';\n      }\n      this.display.draw(x, y, this.map[key], color);\n    }\n  }\n\n  drawStairs(offsetX, offsetY) {\n    if (this.upStairs) {\n      this.display.draw(\n        this.upStairs.x + offsetX,\n        this.upStairs.y + offsetY,\n        '<',\n        'lightblue'\n      );\n    }\n    if (this.downStairs) {\n      this.display.draw(\n        this.downStairs.x + offsetX,\n        this.downStairs.y + offsetY,\n        '>',\n        'lightblue'\n      );\n    }\n  }\n\n  drawHealingItems(offsetX, offsetY, visibleCells) {\n    this.healingItems.forEach(item => {\n      if (visibleCells[`${item.x},${item.y}`]) {\n        this.display.draw(\n          item.x + offsetX,\n          item.y + offsetY,\n          '!',\n          'green'\n        );\n      }\n    });\n  }\n\n  drawWeaponItems(offsetX, offsetY, visibleCells) {\n    this.weaponItems.forEach(weapon => {\n      if (visibleCells[`${weapon.x},${weapon.y}`]) {\n        this.display.draw(\n          weapon.x + offsetX,\n          weapon.y + offsetY,\n          weapon.symbol,\n          weapon.color\n        );\n      }\n    });\n  }\n\n  drawPlayer(offsetX, offsetY) {\n    this.display.draw(\n      this.player.x + offsetX,\n      this.player.y + offsetY,\n      '@',\n      'yellow'\n    );\n  }\n\n  drawEnemies(offsetX, offsetY, visibleCells) {\n    this.enemies.forEach(enemy => {\n      if (visibleCells[`${enemy.x},${enemy.y}`]) {\n        if (enemy.selected) {\n          this.display.draw(\n            enemy.x + offsetX,\n            enemy.y + offsetY,\n            enemy.symbol,\n            enemy.color,\n            'red'\n          );\n        } else {\n          this.display.draw(\n            enemy.x + offsetX,\n            enemy.y + offsetY,\n            enemy.symbol,\n            enemy.color\n          );\n        }\n      }\n    });\n  }\n\n  updateStatus() {\n    document.getElementById('status').innerText =\n      `HP: ${this.player.hp}/${this.player.maxHp}   Floor: ${this.currentFloor}   ` +\n      `Level: ${this.player.level}   EXP: ${this.player.exp}/${this.player.nextExp}   ` +\n      `Potions: ${this.player.inventory.length}   ` +\n      `Weapon: ${this.player.equippedWeapon ? this.player.equippedWeapon.name : 'None'}`;\n  }\n\n  /* 攻撃エフェクト・処理 */\n  showAttackEffect(x, y) {\n    const frames = [\n      { symbol: '!', color: 'orange' },\n      { symbol: '*', color: 'red' },\n      { symbol: '!', color: 'yellow' }\n    ];\n    let frame = 0;\n    const centerX = Math.floor(viewWidth / 2);\n    const centerY = Math.floor(viewHeight / 2);\n    const offsetX = centerX - this.player.x;\n    const offsetY = centerY - this.player.y;\n\n    const interval = setInterval(() => {\n      if (frame < frames.length) {\n        this.display.draw(\n          x + offsetX,\n          y + offsetY,\n          frames[frame].symbol,\n          frames[frame].color\n        );\n        frame++;\n      } else {\n        clearInterval(interval);\n        this.render();\n      }\n    }, 100);\n  }\n\n  playerAttack(enemy) {\n    const bonus = (this.player.equippedWeapon ? this.player.equippedWeapon.bonus : 0);\n    const damage = 5 + bonus;\n    this.attackSound.currentTime = 0;\n    this.attackSound.play().catch(e => console.error('Sound playback error:', e));\n    this.showAttackEffect(enemy.x, enemy.y);\n    enemy.hp -= damage;\n\n    if (enemy.hp <= 0) {\n      // 敵死亡\n      this.enemies = this.enemies.filter(e => e !== enemy);\n      this.gainExperience(10);\n      if (enemy.drop) {\n        const droppedItem = { ...enemy.drop };\n        droppedItem.x = enemy.x;\n        droppedItem.y = enemy.y;\n        this.weaponItems.push(droppedItem);\n        this.showDialogue(`Enemy dropped a ${droppedItem.name}!`);\n      }\n      this.clearEnemyStatus();\n    }\n  }\n\n  enemyAttack(enemy) {\n    this.attackSound.currentTime = 0;\n    this.attackSound.play().catch(e => console.error('Sound playback error:', e));\n    const msg = this.enemyDialogues[Math.floor(Math.random() * this.enemyDialogues.length)];\n    this.enemySpeak(msg);\n    this.showAttackEffect(this.player.x, this.player.y);\n    const damage = 3;\n    this.player.hp -= damage;\n\n    if (this.player.hp <= 0) {\n      // プレイヤー死亡\n      this.gameOver = true;\n    }\n  }\n\n  enemySpeak(message) {\n    const dialogue = document.getElementById('dialogue');\n    dialogue.innerText = message;\n    dialogue.style.display = 'block';\n    setTimeout(() => { dialogue.style.display = 'none'; }, 3000);\n  }\n\n  /* アイテムピックアップ */\n  checkPickup() {\n    for (let i = 0; i < this.healingItems.length; i++) {\n      if (this.player.x === this.healingItems[i].x && this.player.y === this.healingItems[i].y) {\n        this.player.inventory.push(this.healingItems[i]);\n        this.healingItems.splice(i, 1);\n        i--;\n        this.showDialogue('Healing potion picked up!');\n      }\n    }\n\n    for (let i = 0; i < this.weaponItems.length; i++) {\n      if (this.player.x === this.weaponItems[i].x && this.player.y === this.weaponItems[i].y) {\n        this.player.weapons.push(this.weaponItems[i]);\n        this.weaponItems.splice(i, 1);\n        i--;\n        const newWeapon = this.player.weapons[this.player.weapons.length - 1];\n        this.showDialogue(`Picked up a ${newWeapon.name}!`);\n      }\n    }\n  }\n\n  /* 回復ポーション使用 */\n  useHealingItem() {\n    if (this.player.inventory.length > 0) {\n      const potion = this.player.inventory.shift();\n      const healAmount = potion.amount;\n      const oldHp = this.player.hp;\n      this.player.hp = Math.min(this.player.hp + healAmount, this.player.maxHp);\n      this.showDialogue(`Used healing potion: HP ${oldHp} -> ${this.player.hp}`);\n    } else {\n      this.showDialogue('No healing potions!');\n    }\n  }\n\n  /* 武器装備 */\n  equipWeapon() {\n    if (this.player.weapons.length === 0) {\n      this.showDialogue('No weapons in inventory!');\n      return;\n    }\n    let list = '';\n    for (let i = 0; i < this.player.weapons.length; i++) {\n      const w = this.player.weapons[i];\n      list += `${i}: ${w.name} (Bonus: +${w.bonus})\\n`;\n    }\n    const input = window.prompt(`Choose weapon to equip:\\n${list}`, '0');\n    if (input !== null) {\n      const index = parseInt(input);\n      if (!isNaN(index) && index >= 0 && index < this.player.weapons.length) {\n        this.player.equippedWeapon = this.player.weapons[index];\n        this.showDialogue(`Equipped ${this.player.equippedWeapon.name}!`);\n      } else {\n        this.showDialogue('Invalid choice!');\n      }\n    }\n  }\n\n  /* 敵移動 */\n  moveEnemies() {\n    this.enemies.forEach(enemy => {\n      const dx = enemy.x - this.player.x;\n      const dy = enemy.y - this.player.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n      if (!enemy.alerted) {\n        if (dist <= enemy.senseRadius) enemy.alerted = true;\n        else return;\n      }\n\n      // 隣接なら攻撃\n      if (Math.abs(enemy.x - this.player.x) <= 1 &&\n          Math.abs(enemy.y - this.player.y) <= 1) {\n        this.enemyAttack(enemy);\n        return;\n      }\n\n      // 経路探索\n      const astar = new ROT.Path.AStar(\n        this.player.x,\n        this.player.y,\n        (x, y) => {\n          return this.map[`${x},${y}`] === '.';\n        },\n        { topology: 8 }\n      );\n\n      const path = [];\n      astar.compute(enemy.x, enemy.y, (x, y) => {\n        path.push({ x, y });\n      });\n      if (path.length > 1) {\n        enemy.x = path[1].x;\n        enemy.y = path[1].y;\n      }\n    });\n  }\n\n  /* 経験値獲得・レベルアップ */\n  gainExperience(amount) {\n    this.player.exp += amount;\n    while (this.player.exp >= this.player.nextExp) {\n      this.player.exp -= this.player.nextExp;\n      this.player.level++;\n      this.player.nextExp = Math.floor(this.player.nextExp * 1.5);\n      this.player.maxHp += 5;\n      this.player.hp = this.player.maxHp;\n    }\n    this.updateStatus();\n  }\n\n  /* フロア変更 */\n  changeFloor(direction) {\n    if (!this.levels[this.currentFloor]) {\n      this.levels[this.currentFloor] = {};\n    }\n    // 現在のフロア情報を保存\n    this.levels[this.currentFloor].playerPos = { x: this.player.x, y: this.player.y };\n    this.levels[this.currentFloor].healingItems = this.healingItems;\n    this.levels[this.currentFloor].weaponItems = this.weaponItems;\n\n    if (direction === 'down') {\n      const forced = this.levels[this.currentFloor].downStairs;\n      this.currentFloor++;\n      this.generateLevel(forced, null);\n      this.player.x = this.upStairs.x;\n      this.player.y = this.upStairs.y;\n      this.levels[this.currentFloor].playerPos = { x: this.player.x, y: this.player.y };\n    } else if (direction === 'up') {\n      if (this.currentFloor === 1) return;\n      const forced = this.levels[this.currentFloor].upStairs;\n      this.currentFloor--;\n      this.generateLevel(null, forced);\n      this.player.x = this.downStairs.x;\n      this.player.y = this.downStairs.y;\n      this.levels[this.currentFloor].playerPos = { x: this.player.x, y: this.player.y };\n    }\n    this.render();\n  }\n\n  /* 拡大縮小 */\n  updateDisplay() {\n    const container = this.display.getContainer();\n    if (container.parentNode) {\n      container.parentNode.removeChild(container);\n    }\n    // displayOptions.fontSize = cellSize; ← cellSize は直接 import/export しているため\n    displayOptions.fontSize = cellSize;\n\n    this.display = new ROT.Display(displayOptions);\n    this.updateDisplaySize();\n    document.body.appendChild(this.display.getContainer());\n    this.registerTouchEvents();\n    const newContainer = this.display.getContainer();\n    if (newContainer) {\n      newContainer.addEventListener('click', this.onClick.bind(this));\n    }\n    this.render();\n  }\n\n  zoomIn() {\n    // cellSize は参照渡しではなく値渡しだが、config.js 側の変数も更新しておく必要がある\n    // もし「cellSize」をグローバルに扱いたいなら、import ではなく別手段も検討\n    // ここでは簡易的に再代入している\n    window.cellSize = window.cellSize ? window.cellSize + 4 : cellSize + 4;\n    // ただし、上記だとモジュールスコープと衝突する可能性があるため、\n    // 実際には config.js で再代入する関数を提供するなど別方法が望ましい\n    cellSize += 4;\n    this.updateDisplay();\n  }\n\n  zoomOut() {\n    if (cellSize > 8) {\n      cellSize -= 4;\n      this.updateDisplay();\n    }\n  }\n\n  /* 全体マップ表示切替 */\n  toggleOverview() {\n    this.overviewMode = !this.overviewMode;\n    const fullMapContainer = document.getElementById('fullmap');\n    if (this.overviewMode) {\n      if (!this.fullMapDisplay) {\n        this.fullMapDisplay = new ROT.Display({\n          width: levelWidth,\n          height: levelHeight,\n          fontSize: 4,\n          forceSquareRatio: true,\n          bg: 'black',\n          fg: 'white'\n        });\n      }\n      this.renderFullMap();\n      fullMapContainer.innerHTML = '';\n      fullMapContainer.appendChild(this.fullMapDisplay.getContainer());\n      fullMapContainer.style.display = 'block';\n    } else {\n      fullMapContainer.style.display = 'none';\n    }\n  }\n\n  /* 全体マップ描画 */\n  renderFullMap() {\n    this.fullMapDisplay.clear();\n    // マップ\n    for (let key in this.map) {\n      const [xStr, yStr] = key.split(',');\n      const x = parseInt(xStr);\n      const y = parseInt(yStr);\n      let tile = this.map[key];\n      let color = (tile === '#') ? 'grey' : 'lightgrey';\n      this.fullMapDisplay.draw(x, y, tile, color);\n    }\n    // 階段\n    if (this.upStairs) {\n      this.fullMapDisplay.draw(\n        this.upStairs.x,\n        this.upStairs.y,\n        '<',\n        'lightblue'\n      );\n    }\n    if (this.downStairs) {\n      this.fullMapDisplay.draw(\n        this.downStairs.x,\n        this.downStairs.y,\n        '>',\n        'lightblue'\n      );\n    }\n    // アイテム\n    this.healingItems.forEach(item => {\n      this.fullMapDisplay.draw(\n        item.x,\n        item.y,\n        '!',\n        'green'\n      );\n    });\n    this.weaponItems.forEach(weapon => {\n      this.fullMapDisplay.draw(\n        weapon.x,\n        weapon.y,\n        weapon.symbol,\n        weapon.color\n      );\n    });\n\n    // 敵\n    this.enemies.forEach(enemy => {\n      this.fullMapDisplay.draw(\n        enemy.x,\n        enemy.y,\n        enemy.symbol,\n        enemy.color\n      );\n    });\n\n    // プレイヤー\n    this.fullMapDisplay.draw(\n      this.player.x,\n      this.player.y,\n      '@',\n      'yellow'\n    );\n  }\n}\n\n"
  },
  {
    "filename": "main.mjs",
    "content": "import { Game } from './game.mjs';\n\n// ゲーム開始\nconst game = new Game();\n\n"
  }
]
